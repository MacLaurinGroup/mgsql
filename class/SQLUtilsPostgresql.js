/**
 * Postgres
 *
 * (c) 2020 https://maclaurin.group/
 */

const _ = require('underscore');

module.exports = class SQLUtilsPostgresql extends require('./sqlBaseAbstract') {
  /**
   * Builds the UPDATE statement
   * @param {*} tableDef
   * @param {*} table
   * @param {*} tableData
   */
  __sqlUpdate (tableDef, table, tableData) {
    const stmt = {
      sql: null,
      vals: []
    };

    const sqlSet = [];
    const sqlWhere = [];
    let pos = 0;

    // basic values
    for (const col in tableDef.columns) {
      if (!tableDef.keys.includes(col) && _.has(tableData, col)) {
        sqlSet.push(col + '=$' + (++pos));
        stmt.vals.push(tableData[col]);
      }
    }

    // basic values
    for (const col in tableDef.columns) {
      if (tableDef.keys.includes(col) && _.has(tableData, col)) {
        sqlWhere.push(col + '=$' + (++pos));
        stmt.vals.push(tableData[col]);
      }
    }

    stmt.sql = `UPDATE ${table} SET ${sqlSet.join(',')} WHERE ${sqlWhere.join(',')}`;
    return stmt;
  }

  /**
   * Builds an INSERT statement
   *
   * @param {*} tableDef
   * @param {*} table
   * @param {*} tableData
   */
  __sqlInsert (tableDef, table, tableData) {
    const stmt = {
      sql: null,
      vals: []
    };

    const sqlCols = [];
    const sqlVals = [];

    for (const col in tableData) {
      sqlCols.push(col);
      sqlVals.push('$' + (sqlVals.length + 1));
      stmt.vals.push(tableData[col]);
    }

    stmt.sql = `INSERT INTO ${table} (${sqlCols.join(',')}) VALUES (${sqlVals.join(',')}) RETURNING *`;
    return stmt;
  }

  /**
   * Parse the return results
   *
   * @param {*} qResult
   */
  __parseSelectReturn (qResult) {
    if (_.has(qResult, 'rows')) {
      return qResult.rows;
    } else {
      return [];
    }
  }

  /**
   * Parse addition information to get the rows effected
   *
   * @param {*} tableDef
   * @param {*} qResult
   */
  __parseUpdateReturn (tableDef, qResult) {
    if (_.has(qResult, 'rowCount')) {
      return qResult.rowCount;
    } else {
      return qResult;
    }
  }

  /**
   * Parse additional information to get the autogenerated ID
   * @param {*} tableDef
   * @param {*} qResult
   */
  __parseInsertReturn (tableDef, qResult) {
    if (!_.has(qResult, 'rows') || qResult.rows.length === 0) {
      return qResult;
    } else if (tableDef.keys.length > 0 && _.has(qResult.rows[0], tableDef.keys[0])) {
      return qResult.rows[0][tableDef.keys[0]];
    } else {
      return qResult;
    }
  }

  /**
   * Load the table defintion if it is not already available
   *
   * @param {*} dbConn
   * @param {*} table
   */
  async __getTableMetadata (dbConn, table) {
    if (this.dbDefinition.hasTable(table)) {
      return this.dbDefinition.getTable(table);
    }

    const desc = {
      keys: [],
      columns: {}
    };

    const tableParts = table.split('.');
    let schema = null;
    let qResult = null;

    if (tableParts.length === 2) {
      schema = tableParts[0];
      table = tableParts[1];
      qResult = await dbConn.query('SELECT * FROM information_schema.COLUMNS WHERE table_name=$1 and table_schema=$2', [table, schema]);
    } else {
      qResult = await dbConn.query('SELECT * FROM information_schema.COLUMNS WHERE table_name=$1', [table]);
    }

    for (const row of qResult.rows) {
      const field = {
        name: row.column_name,
        dataType: this._getDataType(row.data_type),
        allowNull: (row.is_nullable === 'YES'),
        autoKeyGen: false,
        values: null,
        keyType: null,
        hasDefault: (row.column_default != null),
        len: (row.numeric_precision != null) ? (2 ** row.numeric_precision) : 0
      };

      if (row.identity_generation === 'ALWAYS') {
        field.autoKeyGen = true;
      }

      if (row.character_maximum_length != null) {
        field.len = row.character_maximum_length;
      }

      desc.columns[row.column_name] = field;
    }

    await this._readKeys(dbConn, schema, table, desc);

    return desc;
  }

  async _readEnums (dbConn, schema, name) {
    const qRes = await dbConn.query(SQL_ENUM, [schema, name]);
    const vals = [];

    for (const row of qRes.rows) {
      vals.push(row.enum_value);
    }

    return vals;
  }

  async _readKeys (dbConn, schema, name, desc) {
    const qRes = await dbConn.query(SQL_PK, [schema + '.' + name]);
    for (const row of qRes.rows) {
      desc.keys.push(row.attname);
      desc.columns[row.attname].keyType = this._getDataType(row.data_type);
    }
  }

  _getDataType (pgDataType) {
    if (pgDataType === 'integer') {
      return 'int';
    } else if (pgDataType.startsWith('timestamp')) {
      return 'timestamp';
    } else if (pgDataType === 'character varying') {
      return 'varchar';
    } else if (pgDataType === 'USER-DEFINED') {
      return 'enum';
    } else {
      return pgDataType;
    }
  }
};

const SQL_ENUM = `
select 
  e.enumlabel as enum_value 
from pg_type t 
   join pg_enum e on t.oid = e.enumtypid  
   join pg_catalog.pg_namespace n ON n.oid = t.typnamespace
where
  n.nspname = $1 and t.typname = $2`;

const SQL_PK = `
SELECT 
  a.attname, 
  format_type(a.atttypid, a.atttypmod) AS data_type
FROM
  pg_index i
  JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey)
WHERE
  i.indrelid = $1::regclass
  AND i.indisprimary;
`;
